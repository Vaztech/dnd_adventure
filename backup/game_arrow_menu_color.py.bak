# Created by git commit on 2023-10-01 12:34
import random
import os
import json
import time
import logging
import sys
from typing import Dict, List, Optional, Tuple
from colorama import init, Fore, Style
import msvcrt  # For Windows key detection

# Initialize keyboard library availability
try:
    import keyboard
    KEYBOARD_AVAILABLE = True
except ImportError:
    KEYBOARD_AVAILABLE = False

from dnd_adventure.character import Character
from dnd_adventure.races import get_races
from dnd_adventure.classes import get_all_classes, get_class_by_name
from dnd_adventure.save_manager import SaveManager
from dnd_adventure.world import World, Room, GameWorld, Monster
from dnd_adventure.quest_manager import QuestManager
from dnd_adventure.data_loader import DataLoader
from dnd_adventure.spells import Spell
from dnd_adventure.paths import get_resource_path

# Initialize colorama
init()

# Configure logging to file
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(os.path.join('dnd_adventure', 'dnd_adventure.log')),
        logging.StreamHandler()  # Keep console output for debug
    ]
)
logger = logging.getLogger(__name__)

# Cache for graphics data
_graphics_cache = None

def display_start_menu() -> Tuple[Optional[str], Optional[str]]:
    options = ["Start New Game", "Continue Game", "Delete Save", "Exit"]
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        print(f"{Fore.CYAN}=== D&D Adventure Game ==={Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        for i, option in enumerate(options, 1):
            print(f"{Fore.YELLOW}{i}. {option}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        print(f"\n{Fore.CYAN}Enter the number of your choice (or 'q' to quit):{Style.RESET_ALL}")

        choice = input().strip().lower()
        if choice == 'q':
            return None, None
        try:
            selected_index = int(choice) - 1
            if 0 <= selected_index < len(options):
                if options[selected_index] == "Start New Game":
                    player_name = input(f"{Fore.YELLOW}Enter your character name: {Style.RESET_ALL}").strip()
                    if not player_name:
                        player_name = "Adventurer"
                    return player_name, None
                elif options[selected_index] == "Continue Game":
                    save_files = Game.list_save_files()
                    if not save_files:
                        print(f"{Fore.RED}No saved games found!{Style.RESET_ALL}")
                        input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                        continue
                    selected_save = select_save_file(save_files)
                    if selected_save:
                        player_name = selected_save.split('_')[0].replace('_', ' ').title()
                        return player_name, selected_save
                    continue
                elif options[selected_index] == "Delete Save":
                    save_files = Game.list_save_files()
                    if not save_files:
                        print(f"{Fore.RED}No saved games to delete!{Style.RESET_ALL}")
                        input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                        continue
                    selected_save = select_save_file(save_files)
                    if selected_save:
                        Game.delete_save_file(selected_save)
                        input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                    continue
                elif options[selected_index] == "Exit":
                    return None, None
            else:
                print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(options)}.{Style.RESET_ALL}")
                input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
        except ValueError:
            print(f"{Fore.RED}Invalid input! Please enter a number or 'q' to quit.{Style.RESET_ALL}")
            input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")

def select_save_file(save_files: List[str]) -> Optional[str]:
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        print(f"{Fore.CYAN}=== Select Save File ==={Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        for i, save in enumerate(save_files, 1):
            print(f"{Fore.YELLOW}{i}. {save}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        print(f"\n{Fore.CYAN}Enter the number of your choice (or 'q' to cancel):{Style.RESET_ALL}")

        choice = input().strip().lower()
        if choice == 'q':
            return None
        try:
            selected_index = int(choice) - 1
            if 0 <= selected_index < len(save_files):
                return save_files[selected_index]
            else:
                print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(save_files)}.{Style.RESET_ALL}")
                input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
        except ValueError:
            print(f"{Fore.RED}Invalid input! Please enter a number or 'q' to cancel.{Style.RESET_ALL}")
            input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")

class Game:
    def __init__(self, player_name: str, save_file: Optional[str] = None):
        logger.debug(f"Initializing Game object for player: {player_name}")
        self.player_name = player_name
        logger.debug("Loading graphics...")
        self.graphics = self.load_graphics()
        logger.debug("Creating World...")
        self.world = World(seed=None, graphics=self.graphics)
        logger.debug("Creating GameWorld...")
        self.game_world = GameWorld(self.world)
        logger.debug("Creating QuestManager...")
        self.quest_manager = QuestManager(self.world)
        logger.debug("Creating SaveManager...")
        self.save_manager = SaveManager()
        logger.debug("Initializing player...")
        self.player, self.starting_room = self.initialize_player(save_file)
        logger.debug("Setting current room...")
        self.current_room = self.starting_room
        logger.debug("Finding starting position...")
        self.player_pos = self.find_starting_position()
        logger.debug("Setting game state...")
        self.running = True
        self.mode = "movement"  # Start in movement mode
        self.previous_menu = None
        self.commands = [
            "look", "lore", "attack", "cast", "rest",
            "quest list", "quest start", "quest complete", "save", "quit", "exit"
        ]
        self.current_map = None
        self.last_world_pos = self.player_pos
        self.message = ""  # Store the latest movement message
        self.last_enter_time = 0  # Track time of last Enter keypress for debouncing
        # Set initial current_map and current_room based on starting position
        logger.debug("Setting initial map and room...")
        tile = self.world.get_location(*self.player_pos)
        if tile["type"] in self.graphics["maps"]:
            self.current_map = tile["type"]
            self.player_pos = (2, 2)  # Center of the mini-map
        # Ensure current_room is set correctly for the starting position
        self.current_room = f"{self.last_world_pos[0]},{self.last_world_pos[1]}" if tile["type"] in ["dungeon", "castle"] else None
        logger.debug(f"Game initialized: map={self.current_map}, room={self.current_room}, pos={self.player_pos}")

    def get_xp_for_level(self, level: int) -> int:
        if level <= 1:
            return 0
        inoculated_level = level - 2
        if level == 2:
            return 300
        return 300 * (3 ** inoculated_level)

    def check_level_up(self):
        current_level = self.player.level
        next_level = current_level + 1
        xp_required = self.get_xp_for_level(next_level)
        
        while self.player.xp >= xp_required and next_level <= 20:
            self.player.level = next_level
            self.player.max_hit_points += 5
            self.player.hit_points = self.player.max_hit_points
            self.player.max_mp += 3
            self.player.mp = self.player.max_mp
            print(f"{Fore.GREEN}Congratulations! {self.player.name} has reached level {self.player.level}!{Style.RESET_ALL}")
            print(f"HP increased to {self.player.max_hit_points}, MP increased to {self.player.max_mp}.")
            logger.info(f"Player {self.player.name} leveled up to {self.player.level}")
            next_level += 1
            xp_required = self.get_xp_for_level(next_level)

    def calculate_monster_difficulty(self, monster: Monster) -> float:
        hp_score = monster.hp
        ac_score = monster.armor_class * 2
        damage_score = 0
        if monster.attacks:
            for attack in monster.attacks:
                damage_str = attack.get("damage", "1d4")
                parts = damage_str.split('+')
                dice_part = parts[0]
                bonus = int(parts[1]) if len(parts) > 1 else 0
                num_dice, die_size = map(int, dice_part.split('d'))
                avg_damage_per_die = (1 + die_size) / 2
                avg_damage = (num_dice * avg_damage_per_die) + bonus
                damage_score += avg_damage
            damage_score *= 2
        difficulty = hp_score + ac_score + damage_score
        return max(1, difficulty)

    def calculate_xp_reward(self, monster: Monster) -> int:
        difficulty = self.calculate_monster_difficulty(monster)
        scaling_factor = 50 / 33
        xp = int(difficulty * scaling_factor)
        return max(10, xp)

    def find_starting_position(self) -> Tuple[int, int]:
        x, y = 96, 96  # Center of the 192x192 map
        max_distance = 30  # Increased search radius for larger map
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # North, South, East, West
        for distance in range(max_distance):
            for dx in range(-distance, distance + 1):
                for dy in range(-distance, distance + 1):
                    new_x, new_y = x + dx, y + dy
                    if (0 <= new_x < self.world.map["width"] and 
                        0 <= new_y < self.world.map["height"]):
                        tile = self.world.get_location(new_x, new_y)
                        if tile["type"] == "plains":
                            # Check for at least one adjacent traversable tile (plains or forest)
                            has_exit = False
                            for dir_dx, dir_dy in directions:
                                adj_x, adj_y = new_x + dir_dx, new_y + dir_dy
                                if (0 <= adj_x < self.world.map["width"] and 
                                    0 <= adj_y < self.world.map["height"]):
                                    adj_tile = self.world.get_location(adj_x, adj_y)
                                    if adj_tile["type"] in ["plains", "forest"]:
                                        has_exit = True
                                        break
                            if has_exit:
                                logger.debug(f"Starting position found: ({new_x}, {new_y})")
                                return (new_x, new_y)
        logger.debug(f"Fallback starting position: ({x}, {y})")
        return (x, y)  # Fallback position if no suitable spot is found

    def load_graphics(self):
        global _graphics_cache
        if _graphics_cache is not None:
            logger.debug("Using cached graphics data")
            return _graphics_cache
        graphics_path = get_resource_path("graphics.json")
        logger.debug(f"Reading graphics.json from {graphics_path}")
        try:
            with open(graphics_path, "r", encoding="utf-8") as f:
                _graphics_cache = json.load(f)
            logger.debug("Graphics loaded and cached")
            return _graphics_cache
        except Exception as e:
            logger.error(f"Failed to load graphics: {e}")
            raise

    @staticmethod
    def list_save_files() -> List[str]:
        saves_dir = os.path.join("dnd_adventure", "saves")
        os.makedirs(saves_dir, exist_ok=True)
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".save")]
        logger.debug(f"Save files found: {save_files}")
        return save_files

    @staticmethod
    def delete_save_file(save_file: str) -> bool:
        save_path = os.path.join("dnd_adventure", "saves", save_file)
        try:
            os.remove(save_path)
            print(f"{Fore.GREEN}Deleted save file: {save_file}{Style.RESET_ALL}")
            logger.info(f"Deleted save file: {save_file}")
            return True
        except Exception as e:
            print(f"{Fore.RED}Failed to delete {save_file}: {e}{Style.RESET_ALL}")
            logger.error(f"Failed to delete {save_file}: {e}")
            return False

    def initialize_player(self, save_file: Optional[str]) -> Tuple[Character, Optional[str]]:
        logger.debug(f"Initializing player, save_file={save_file}")
        if save_file:
            try:
                player_data = self.save_manager.load_game(save_file)
                player = Character(**player_data)
                starting_room = player_data.get("current_room")
                self.player_pos = tuple(player_data.get("player_pos", (0, 0)))
                logger.info(f"Loaded character {self.player_name} from {save_file}")
                return player, starting_room
            except Exception as e:
                logger.error(f"Failed to load save file {save_file}: {e}")
                print(f"{Fore.RED}Failed to load save: {e}. Starting new game.{Style.RESET_ALL}")
        logger.debug("Creating new player")
        player = self.create_player(self.player_name)
        logger.debug("Finding starting room")
        starting_room = next((room_id for room_id in self.game_world.rooms if self.game_world.world.get_location(*map(int, room_id.split(',')))["type"] == "dungeon"), None)
        if starting_room:
            self.player_pos = tuple(map(int, starting_room.split(",")))
        logger.debug("Displaying initial lore")
        self.display_initial_lore(player)
        logger.debug("Player initialization complete")
        return player, starting_room

    def display_initial_lore(self, character: Character):
        random.seed(hash(self.player_name + self.world.name))
        os.system('cls' if os.name == 'nt' else 'clear')
        print(f"{Fore.CYAN}=== The Prophecy of {self.world.name} ==={Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        era = random.choice(self.world.history)
        event = random.choice(era["events"])
        prophecies = [
            f"In the {era['name']}, the seers foretold that {character.name}, a {character.race_name} {character.class_name}, would rise to reclaim {event['desc'].split('discovers the ')[-1]} and restore balance.",
            f"Legends from {event['year']} speak of {character.name}, born under the stars of {self.world.name}, destined to confront the {random.choice(['dragon', 'lich', 'demon'])} that threatens {self.world.name}.",
            f"The chronicles of {era['name']} whisper of {character.name}, a {character.class_name}, who will forge a new era by fulfilling the legacy of {event['desc'].split('is founded by ')[-1]}."
        ]
        prophecy = random.choice(prophecies)
        print(f"{Fore.LIGHTYELLOW_EX}{prophecy}{Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        print(f"\n{Fore.YELLOW}Your journey begins, {character.name}. The fate of {self.world.name} rests in your hands.{Style.RESET_ALL}")
        input(f"\n{Fore.CYAN}Press Enter to embark on your adventure...{Style.RESET_ALL}")
        logger.debug(f"Displayed initial lore: {prophecy}")
        random.seed(None)

    def create_player(self, name: str) -> Character:
        print(f"\n{Fore.CYAN}=== Creating character: {name} ==={Style.RESET_ALL}")
        logger.debug(f"Creating character: {name}")
        selections = {}
        
        races = get_races()
        selections["race"] = self.select_race(races)
        
        selected_race = next((r for r in races if r.name == selections["race"]), None)
        if not selected_race:
            logger.error("Selected race not found")
            raise ValueError("Selected race not found")
        
        if selected_race.subraces:
            subrace_names = list(selected_race.subraces.keys()) + ["Base " + selections["race"]]
            selections["subrace"] = self.select_subrace(subrace_names, selected_race)
        else:
            selections["subrace"] = None
        
        classes = get_all_classes()
        selections["class"] = self.select_class(classes)
        
        selections["stats"] = self.roll_stats(selected_race, selections["subrace"], classes, selections["class"])
        
        spellcasting_classes = ["Wizard", "Sorcerer", "Cleric", "Druid", "Bard", "Paladin", "Ranger"]
        if selections["class"] in spellcasting_classes:
            selections["spells"] = self.select_spells(selections["class"])
        else:
            selections["spells"] = {0: [], 1: []}
        
        selections = self.review_selections(selections, races, classes)
        
        race = next((r for r in races if r.name == selections["race"]), None)
        if selections["subrace"] and selections["subrace"] != "Base " + selections["race"]:
            race.subrace = selections["subrace"]
        
        dnd_class = next((c for c in classes if c["name"] == selections["class"]), None)
        stats = selections["stats"]
        spells = selections.get("spells", {0: [], 1: []})
        
        if not race or not dnd_class:
            logger.error("Selected race or class not found")
            raise ValueError("Selected race or class not found")
        
        character = Character(
            name=name,
            race_name=selections["race"] if not selections["subrace"] or selections["subrace"] == "Base " + selections["race"] else selections["subrace"],
            class_name=selections["class"],
            stats=stats,
            known_spells=spells
        )
        race.apply_modifiers(character)
        self.display_character_sheet(character, race, dnd_class)
        logger.debug(f"Character created: {character.name}, {character.race_name}, {character.class_name}")
        return character

    def display_character_sheet(self, character: Character, race_obj: 'Race', dnd_class: Dict) -> None:
        print(f"\n{Fore.CYAN}=== Character Sheet ==={Style.RESET_ALL}")
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        
        print(f"{Fore.YELLOW}Name: {Fore.WHITE}{character.name}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Health: {Fore.WHITE}{character.hit_points}/{character.max_hit_points}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Magic Points: {Fore.WHITE}{character.mp}/{character.max_mp}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Level: {Fore.WHITE}{character.level}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Experience Points: {Fore.WHITE}{character.xp}{Style.RESET_ALL}")
        race_display = character.race_name
        print(f"{Fore.YELLOW}Race: {Fore.WHITE}{race_display}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Class: {Fore.WHITE}{character.class_name}{Style.RESET_ALL}")
        
        stat_names = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"]
        print(f"\n{Fore.YELLOW}Stats:{Style.RESET_ALL}")
        for i, stat in enumerate(character.stats):
            print(f"  {Fore.WHITE}{stat_names[i]}: {stat}{Style.RESET_ALL}")
        
        print(f"\n{Fore.YELLOW}Racial Traits:{Style.RESET_ALL}")
        for trait in race_obj.racial_traits:
            print(f"  {Fore.WHITE}{trait.name}: {Fore.LIGHTYELLOW_EX}{trait.description}{Style.RESET_ALL}")
        if race_obj.subrace and race_obj.subrace in race_obj.subraces:
            subrace_traits = race_obj.subraces[race_obj.subrace].get("racial_traits", [])
            for trait in subrace_traits:
                print(f"  {Fore.WHITE}{trait['name']}: {Fore.LIGHTYELLOW_EX}{trait['description']}{Style.RESET_ALL}")
        
        print(f"\n{Fore.YELLOW}Class Features:{Style.RESET_ALL}")
        for feature in dnd_class.get("features", []):
            if feature["level"] == 1:
                print(f"  {Fore.WHITE}{feature['name']}: {Fore.LIGHTYELLOW_EX}{feature['description']}{Style.RESET_ALL}")
        
        print(f"\n{Fore.YELLOW}Spells:{Style.RESET_ALL}")
        if not character.known_spells or all(not spells for spells in character.known_spells.values()):
            print(f"  {Fore.WHITE}None{Style.RESET_ALL}")
        else:
            loader = DataLoader()
            spells_data = loader.load_spells_from_json()
            class_key = "Sorcerer/Wizard" if character.class_name in ["Wizard", "Sorcerer"] else character.class_name
            for level in sorted(character.known_spells.keys()):
                for spell_name in character.known_spells.get(level, []):
                    spell_obj = None
                    for spell in spells_data.get(class_key, {}).get(level, []):
                        if spell.name == spell_name:
                            spell_obj = spell
                            break
                    if spell_obj:
                        print(f"  {Fore.WHITE}Level {level} - {spell_obj.name}: {Fore.LIGHTYELLOW_EX}{spell_obj.description}{Style.RESET_ALL}")
                    else:
                        print(f"  {Fore.WHITE}Level {level} - {spell_name}: {Fore.LIGHTYELLOW_EX}(Description not found){Style.RESET_ALL}")
        
        print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
        input(f"\n{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
        logger.debug("Displayed character sheet")

    def select_race(self, races: List) -> str:
        while True:
            os.system('cls' if os.name == 'nt' else 'clear')
            print(f"{Fore.CYAN}=== Select Your Race ==={Style.RESET_ALL}")
            print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            for i, race in enumerate(races, 1):
                desc = race.description[:100] + "..." if len(race.description) > 100 else race.description
                print(f"{Fore.YELLOW}{i}. {race.name}{Style.RESET_ALL}")
                print(f"     {Fore.LIGHTYELLOW_EX}{desc}{Style.RESET_ALL}")
                print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            print(f"\n{Fore.CYAN}Enter the number of your chosen race (or 'q' to quit):{Style.RESET_ALL}")
            
            choice = input().strip().lower()
            if choice == 'q':
                logger.info("Game exited during race selection")
                exit()
            try:
                choice_index = int(choice) - 1
                if 0 <= choice_index < len(races):
                    logger.debug(f"Selected race: {races[choice_index].name}")
                    return races[choice_index].name
                else:
                    print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(races)}.{Style.RESET_ALL}")
                    logger.warning(f"Invalid race choice: {choice}")
                    input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
            except ValueError:
                print(f"{Fore.RED}Invalid input! Please enter a number or 'q' to quit.{Style.RESET_ALL}")
                logger.warning(f"Invalid race input: {choice}")
                input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")

    def select_subrace(self, subrace_names: List[str], race: 'Race') -> str:
        while True:
            os.system('cls' if os.name == 'nt' else 'clear')
            print(f"{Fore.CYAN}=== Select Subrace for {race.name} ==={Style.RESET_ALL}")
            print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            for i, subrace in enumerate(subrace_names, 1):
                if subrace.startswith("Base "):
                    desc = race.description
                else:
                    desc = race.subraces[subrace]["description"]
                desc = desc[:100] + "..." if len(desc) > 100 else desc
                print(f"{Fore.YELLOW}{i}. {subrace}{Style.RESET_ALL}")
                print(f"     {Fore.LIGHTYELLOW_EX}{desc}{Style.RESET_ALL}")
                print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            print(f"\n{Fore.CYAN}Enter the number of your chosen subrace (or 'q' to quit):{Style.RESET_ALL}")
            
            choice = input().strip().lower()
            if choice == 'q':
                logger.info("Game exited during subrace selection")
                exit()
            try:
                choice_index = int(choice) - 1
                if 0 <= choice_index < len(subrace_names):
                    logger.debug(f"Selected subrace: {subrace_names[choice_index]}")
                    return subrace_names[choice_index]
                else:
                    print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(subrace_names)}.{Style.RESET_ALL}")
                    logger.warning(f"Invalid subrace choice: {choice}")
                    input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
            except ValueError:
                print(f"{Fore.RED}Invalid input! Please enter a number or 'q' to quit.{Style.RESET_ALL}")
                logger.warning(f"Invalid subrace input: {choice}")
                input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")

    def select_class(self, classes: List[Dict]) -> str:
        while True:
            os.system('cls' if os.name == 'nt' else 'clear')
            print(f"{Fore.CYAN}=== Select Your Class ==={Style.RESET_ALL}")
            print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            for i, cls in enumerate(classes, 1):
                desc = cls["description"][:100] + "..." if len(cls["description"]) > 100 else cls["description"]
                print(f"{Fore.YELLOW}{i}. {cls['name']}{Style.RESET_ALL}")
                print(f"     {Fore.LIGHTYELLOW_EX}{desc}{Style.RESET_ALL}")
                print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            print(f"\n{Fore.CYAN}Enter the number of your chosen class (or 'q' to quit):{Style.RESET_ALL}")
            
            choice = input().strip().lower()
            if choice == 'q':
                logger.info("Game exited during class selection")
                exit()
            try:
                choice_index = int(choice) - 1
                if 0 <= choice_index < len(classes):
                    logger.debug(f"Selected class: {classes[choice_index]['name']}")
                    return classes[choice_index]["name"]
                else:
                    print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(classes)}.{Style.RESET_ALL}")
                    logger.warning(f"Invalid class choice: {choice}")
                    input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
            except ValueError:
                print(f"{Fore.RED}Invalid input! Please enter a number or 'q' to quit.{Style.RESET_ALL}")
                logger.warning(f"Invalid class input: {choice}")
                input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")

    def roll_stats(self, race: 'Race', subrace: Optional[str], classes: List[Dict], class_name: str) -> List[int]:
        stat_names = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"]
        stats = []
        print(f"\n{Fore.CYAN}=== Rolling Stats (4d6, drop lowest) ==={Style.RESET_ALL}")
        logger.debug("Rolling stats")
        for i in range(6):
            rolls = [random.randint(1, 6) for _ in range(4)]
            rolls.remove(min(rolls))
            stat = sum(rolls)
            stats.append(stat)
            print(f"{stat_names[i]}: {stat}")
        
        print(f"\n{Fore.YELLOW}=== Applying Bonuses ==={Style.RESET_ALL}")
        racial_mods = race.ability_modifiers
        if racial_mods:
            print(f"{Fore.YELLOW}Racial Bonuses ({race.name}):{Style.RESET_ALL}")
            for stat, mod in racial_mods.items():
                print(f"  {stat}: {'+' if mod >= 0 else ''}{mod}")
        else:
            print(f"{Fore.YELLOW}Racial Bonuses ({race.name}): None{Style.RESET_ALL}")
        
        subrace_mods = {}
        if subrace and subrace != "Base " + race.name and race.subraces and subrace in race.subraces:
            subrace_mods = race.subraces[subrace].get("ability_modifiers", {})
            if subrace_mods:
                print(f"{Fore.YELLOW}Subrace Bonuses ({subrace}):{Style.RESET_ALL}")
                for stat, mod in subrace_mods.items():
                    print(f"  {stat}: {'+' if mod >= 0 else ''}{mod}")
            else:
                print(f"{Fore.YELLOW}Subrace Bonuses ({subrace}): None{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}Subrace Bonuses: None{Style.RESET_ALL}")
        
        dnd_class = next((c for c in classes if c["name"] == class_name), None)
        if dnd_class:
            print(f"{Fore.YELLOW}Class Bonuses ({class_name}):{Style.RESET_ALL}")
            print(f"  Class Skills: {', '.join(dnd_class['class_skills'])}")
            if dnd_class["features"]:
                print(f"  Features at Level 1:")
                for feature in dnd_class["features"]:
                    if feature["level"] == 1:
                        print(f"    - {feature['name']}: {feature['description']}")
        else:
            print(f"{Fore.YELLOW}Class Bonuses: None{Style.RESET_ALL}")
        
        stat_indices = {name: i for i, name in enumerate(stat_names)}
        modified_stats = stats.copy()
        for stat, mod in racial_mods.items():
            if stat in stat_indices:
                modified_stats[stat_indices[stat]] += mod
        for stat, mod in subrace_mods.items():
            if stat in stat_indices:
                modified_stats[stat_indices[stat]] += mod
        
        print(f"\n{Fore.GREEN}=== Final Stats ==={Style.RESET_ALL}")
        for i, stat in enumerate(modified_stats):
            print(f"{stat_names[i]}: {stat}")
        
        input(f"\n{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
        logger.debug(f"Stats rolled: {modified_stats}")
        return modified_stats

    def select_spells(self, class_name: str) -> Dict[int, List[str]]:
        spells = {0: [], 1: []}
        available_spells = self.get_available_spells(class_name)
        max_spells = 4 if class_name in ["Wizard", "Sorcerer"] else 3
        
        for level in [0, 1]:
            if level in available_spells and available_spells[level]:
                print(f"\n{Fore.CYAN}=== Select up to {max_spells} Level {level} Spells for {class_name} ==={Style.RESET_ALL}")
                selected_spells = []
                while len(selected_spells) < max_spells and available_spells[level]:
                    os.system('cls' if os.name == 'nt' else 'clear')
                    print(f"{Fore.CYAN}Level {level} Spells (Selected {len(selected_spells)}/{max_spells}){Style.RESET_ALL}")
                    print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
                    for i, spell in enumerate(available_spells[level], 1):
                        status = " [Selected]" if spell in selected_spells else ""
                        print(f"{Fore.YELLOW}{i}. {spell}{status}{Style.RESET_ALL}")
                    print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
                    print(f"\n{Fore.CYAN}Enter the number to select/deselect a spell (or 'q' to finish):{Style.RESET_ALL}")
                    
                    choice = input().strip().lower()
                    if choice == 'q':
                        break
                    try:
                        spell_index = int(choice) - 1
                        if 0 <= spell_index < len(available_spells[level]):
                            spell = available_spells[level][spell_index]
                            if spell in selected_spells:
                                selected_spells.remove(spell)
                            else:
                                selected_spells.append(spell)
                            logger.debug(f"Spell {spell} {'deselected' if spell not in selected_spells else 'selected'}")
                        else:
                            print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(available_spells[level])}.{Style.RESET_ALL}")
                            logger.warning(f"Invalid spell choice: {choice}")
                            input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                    except ValueError:
                        print(f"{Fore.RED}Invalid input! Please enter a number or 'q' to finish.{Style.RESET_ALL}")
                        logger.warning(f"Invalid spell input: {choice}")
                        input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                spells[level] = selected_spells
        logger.debug(f"Selected spells: {spells}")
        return spells

    def get_available_spells(self, class_name: str) -> Dict[int, List[str]]:
        loader = DataLoader()
        spells_data = loader.load_spells_from_json()
        class_key = "Sorcerer/Wizard" if class_name in ["Wizard", "Sorcerer"] else class_name
        spells = {level: [spell.name for spell in spells] for level, spells in spells_data.get(class_key, {}).items() if level in [0, 1]}
        logger.debug(f"Available spells for {class_name}: {spells}")
        return spells

    def review_selections(self, selections: Dict, races: List, classes: List[Dict]) -> Dict:
        selections = selections or {"race": None, "subrace": None, "class": None, "stats": [], "spells": {0: [], 1: []}}
        stat_names = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"]
        options = ["Change race", "Change class", "Reroll stats", "Change spells", "Confirm selections"]
        
        while True:
            os.system('cls' if os.name == 'nt' else 'clear')
            print(f"{Fore.CYAN}=== Review Your Selections ==={Style.RESET_ALL}")
            print(f"{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            
            race_display = selections["race"] if not selections["subrace"] or selections["subrace"] == "Base " + selections["race"] else f"{selections['race']} ({selections['subrace']})"
            race_obj = next((r for r in races if r.name == selections["race"]), None)
            race_desc = race_obj.description if race_obj else "Not selected"
            race_desc = race_desc[:100] + "..." if len(race_desc) > 100 else race_desc
            print(f"{Fore.YELLOW}Race: {race_display or 'Not selected'}{Style.RESET_ALL}")
            print(f"  {Fore.LIGHTYELLOW_EX}{race_desc}{Style.RESET_ALL}")
            if race_obj and selections["subrace"] and selections["subrace"] != "Base " + selections["race"]:
                subrace_desc = race_obj.subraces[selections["subrace"]]["description"]
                subrace_desc = subrace_desc[:100] + "..." if len(subrace_desc) > 100 else subrace_desc
                print(f"  {Fore.LIGHTYELLOW_EX}Subrace: {subrace_desc}{Style.RESET_ALL}")
            
            class_obj = next((c for c in classes if c["name"] == selections["class"]), None)
            class_desc = class_obj["description"] if class_obj else "Not selected"
            class_desc = class_desc[:100] + "..." if len(class_desc) > 100 else class_desc
            print(f"\n{Fore.YELLOW}Class: {selections['class'] or 'Not selected'}{Style.RESET_ALL}")
            print(f"  {Fore.LIGHTYELLOW_EX}{class_desc}{Style.RESET_ALL}")
            
            print(f"\n{Fore.YELLOW}Stats:{Style.RESET_ALL}")
            for i, stat in enumerate(selections["stats"]):
                print(f"  {stat_names[i]}: {stat}")
            
            spells_display = "None"
            if selections["spells"] and any(selections["spells"].values()):
                spells_display = ", ".join([f"Level {k}: {', '.join(v)}" for k, v in selections["spells"].items() if v])
            print(f"\n{Fore.YELLOW}Spells: {spells_display}{Style.RESET_ALL}")
            
            print(f"\n{Fore.LIGHTBLACK_EX}----------------------------------------{Style.RESET_ALL}")
            print(f"{Fore.CYAN}Options:{Style.RESET_ALL}")
            for i, option in enumerate(options, 1):
                print(f"{Fore.YELLOW}{i}. {option}{Style.RESET_ALL}")
            print(f"\n{Fore.CYAN}Enter the number of your choice:{Style.RESET_ALL}")
            
            choice = input().strip()
            try:
                selected_index = int(choice) - 1
                if not 0 <= selected_index < len(options):
                    print(f"{Fore.RED}Invalid choice! Please select a number between 1 and {len(options)}.{Style.RESET_ALL}")
                    logger.warning(f"Invalid selection review choice: {choice}")
                    input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                    continue
            except ValueError:
                print(f"{Fore.RED}Invalid input! Please enter a number.{Style.RESET_ALL}")
                logger.warning(f"Invalid selection review input: {choice}")
                input(f"{Fore.CYAN}Press Enter to continue...{Style.RESET_ALL}")
                continue
            
            if selected_index == 0:
                selections["race"] = self.select_race(races)
                selected_race = next((r for r in races if r.name == selections["race"]), None)
                if selected_race and selected_race.subraces:
                    subrace_names = list(selected_race.subraces.keys()) + ["Base " + selections["race"]]
                    selections["subrace"] = self.select_subrace(subrace_names, selected_race)
                else:
                    selections["subrace"] = None
            elif selected_index == 1:
                selections["class"] = self.select_class(classes)
            elif selected_index == 2:
                selected_race = next((r for r in races if r.name == selections["race"]), None)
                if selected_race:
                    selections["stats"] = self.roll_stats(selected_race, selections["subrace"], classes, selections["class"])
            elif selected_index == 3:
                spellcasting_classes = ["Wizard", "Sorcerer", "Cleric", "Druid", "Bard", "Paladin", "Ranger"]
                if selections["class"] in spellcasting_classes:
                    selections["spells"] = self.select_spells(selections["class"])
                else:
                    selections["spells"] = {0: [], 1: []}
            elif selected_index == 4:
                logger.debug(f"Selections confirmed: {selections}")
                return selections

    def display_current_map(self):
        os.system('cls' if os.name == 'nt' else 'clear')
        tile = self.world.get_location(*self.last_world_pos)
        country_id = tile.get("country")
        country_name = "Unknown Lands"
        if country_id is not None:
            country = next((c for c in self.world.map["countries"] if c["id"] == country_id), None)
            if country:
                country_name = country["name"]
        
        if self.current_map:  # Display mini-map if available
            map_data = self.graphics["maps"][self.current_map]
            print(f"\n{Fore.CYAN}{map_data['description']} ({tile['name']} in {country_name}){Style.RESET_ALL}")
            for y, row in enumerate(map_data["layout"]):
                line = ""
                for x, char in enumerate(row):
                    if (x, len(map_data["layout"]) - 1 - y) == self.player_pos:
                        line += Fore.RED + "@" + Style.RESET_ALL
                    elif char == '@':  # Skip rendering '@' in the layout since player position is handled
                        line += " "  # Replace with a space or appropriate placeholder
                    else:
                        symbol_data = map_data["symbols"].get(char, {"symbol": char, "color": "white", "type": "unknown"})
                        symbol = symbol_data["symbol"]
                        color = symbol_data["color"]
                        if color == "gray":
                            line += Fore.LIGHTBLACK_EX + symbol + Style.RESET_ALL
                        elif color == "dark_green":
                            line += Fore.GREEN + symbol + Style.RESET_ALL
                        elif color == "green":
                            line += Fore.GREEN + symbol + Style.RESET_ALL
                        elif color == "light_green":
                            line += Fore.LIGHTGREEN_EX + symbol + Style.RESET_ALL
                        elif color == "light_green_ex":
                            line += Fore.LIGHTGREEN_EX + symbol + Style.RESET_ALL
                        elif color == "blue":
                            line += Fore.BLUE + symbol + Style.RESET_ALL
                        elif color == "light_blue_ex":
                            line += Fore.LIGHTBLUE_EX + symbol + Style.RESET_ALL
                        elif color == "cyan":
                            line += Fore.CYAN + symbol + Style.RESET_ALL
                        elif color == "light_cyan_ex":
                            line += Fore.LIGHTCYAN_EX + symbol + Style.RESET_ALL
                        elif color == "yellow":
                            line += Fore.YELLOW + symbol + Style.RESET_ALL
                        elif color == "light_yellow_ex":
                            line += Fore.LIGHTYELLOW_EX + symbol + Style.RESET_ALL
                        elif color == "red":
                            line += Fore.RED + symbol + Style.RESET_ALL
                        elif color == "light_red_ex":
                            line += Fore.LIGHTRED_EX + symbol + Style.RESET_ALL
                        elif color == "brown":
                            line += Fore.LIGHTRED_EX + symbol + Style.RESET_ALL
                        elif color == "magenta":
                            line += Fore.MAGENTA + symbol + Style.RESET_ALL
                        elif color == "light_magenta_ex":
                            line += Fore.LIGHTMAGENTA_EX + symbol + Style.RESET_ALL
                        elif color == "light_black_ex":
                            line += Fore.LIGHTBLACK_EX + symbol + Style.RESET_ALL
                        elif color == "white":
                            line += Fore.WHITE + symbol + Style.RESET_ALL
                        elif color == "light_white_ex":
                            line += Fore.LIGHTWHITE_EX + symbol + Style.RESET_ALL
                        elif color == "black":
                            line += Fore.BLACK + symbol + Style.RESET_ALL
                        else:
                            print(f"{Fore.YELLOW}Warning: Unsupported color '{color}' for symbol '{symbol}' in {self.current_map} map. Using default color.{Style.RESET_ALL}")
                            logger.warning(f"Unsupported color '{color}' for symbol '{symbol}' in {self.current_map} map")
                            line += symbol  # Fallback: no color applied
                print(line)
        else:  # Fall back to world map
            print(f"\n{Fore.CYAN}You are in {tile['name']} at ({self.last_world_pos[0]},{self.last_world_pos[1]}) ({tile['type'].capitalize()}) in {country_name}{Style.RESET_ALL}")
            print(self.world.display_map(self.last_world_pos))
        
        if self.current_room:
            expected_room = f"{self.last_world_pos[0]},{self.last_world_pos[1]}" if tile["type"] in ["dungeon", "castle"] else None
            if self.current_room != expected_room:
                print(f"{Fore.RED}Position mismatch detected! Expected room: {expected_room}, Current room: {self.current_room}. Resetting room.{Style.RESET_ALL}")
                logger.error(f"Position mismatch: Expected room {expected_room}, Current room {self.current_room}")
                self.current_room = expected_room
            if self.current_room:
                room = self.game_world.rooms.get(self.current_room)
                if room:
                    room.visited = True
                    print(f"\n{room.description}")
                    exits = ", ".join(room.exits.keys())
                    print(f"Exits: {exits if exits else 'None'}")
                    if room.monsters:
                        print(f"Monsters: {', '.join(m.name for m in room.monsters)}")
                    if room.items:
                        print(f"Items: {', '.join(room.items)}")
                else:
                    print(f"{Fore.RED}Error: Room {self.current_room} not found! Resetting room.{Style.RESET_ALL}")
                    logger.error(f"Room not found: {self.current_room}")
                    self.current_room = None
        logger.debug(f"Displayed map: map={self.current_map}, room={self.current_room}, pos={self.player_pos}")

    def handle_command(self, cmd: str):
        self.message = ""  # Clear previous message
        logger.debug(f"Handling command: {cmd}")
        cmd = cmd.lower().strip()
        if cmd == "look":
            self.display_current_map()
        elif cmd == "lore":
            self.print_lore()
        elif cmd == "attack":
            self.handle_attack_command()
        elif cmd.startswith("cast "):
            self.handle_cast_command(cmd)
        elif cmd == "cast list":
            self.print_spell_list()
        elif cmd == "rest":
            self.handle_rest_command()
        elif cmd == "quest list":
            self.quest_manager.quest_list()
        elif cmd.startswith("quest start "):
            try:
                quest_id = int(cmd.split()[-1])
                self.quest_manager.start_quest(quest_id)
            except ValueError:
                print(f"{Fore.RED}Invalid quest ID. Use 'quest start <number>'.{Style.RESET_ALL}")
                logger.warning(f"Invalid quest ID: {cmd}")
        elif cmd == "quest complete":
            for quest in self.quest_manager.active_quests:
                self.quest_manager.complete_quest(quest["id"], self.player, self.last_world_pos, self.current_room)
        elif cmd == "save":
            self.save_game()
        elif cmd in ["quit", "exit"]:
            self.running = False
            logger.info("Game quit by user")
        elif cmd in ["north", "south", "east", "west", "n", "s", "e", "w"]:
            print(f"{Fore.RED}Movement is controlled with arrow keys only. Use up, down, left, right keys.{Style.RESET_ALL}")
            logger.debug(f"Attempted movement command: {cmd}")
        elif cmd == "help":
            print(f"{Fore.YELLOW}Available commands: {', '.join(self.commands)}{Style.RESET_ALL}")
            logger.debug("Displayed help commands")
        elif cmd:
            print(f"{Fore.RED}Unknown command '{cmd}'. Try: {', '.join(self.commands)}{Style.RESET_ALL}")
            logger.warning(f"Unknown command: {cmd}")

    def handle_movement(self, direction: str):
        self.message = ""  # Clear previous message
        logger.debug(f"Handling movement: {direction}")
        if self.current_map:  # Moving within a mini-map
            x, y = self.player_pos
            dx, dy = {"north": (0, 1), "south": (0, -1), "east": (1, 0), "west": (-1, 0)}[direction]
            new_pos = (x + dx, y + dy)
            map_data = self.graphics["maps"][self.current_map]
            new_x, new_y = new_pos
            adjusted_y = len(map_data["layout"]) - 1 - new_y
            if (new_x < 0 or new_x >= len(map_data["layout"][0]) or
                new_y < 0 or new_y >= len(map_data["layout"])):
                # Exit the mini-map, return to world map
                self.current_map = None
                self.player_pos = self.last_world_pos
                self.current_room = None
                self.message = f"You exit the {self.current_map} and return to the world map."
                logger.debug(f"Exited mini-map to world map at {self.last_world_pos}")
            else:
                char = map_data["layout"][adjusted_y][new_x]
                symbol_type = map_data["symbols"].get(char, {"type": "unknown"})["type"]
                if symbol_type in ["wall", "building", "house", "tree"]:
                    self.message = f"You can't move {direction}! A {symbol_type} blocks your path."
                    logger.debug(f"Blocked movement {direction}: {symbol_type}")
                elif symbol_type == "door":
                    if self.current_map in ["castle", "dungeon"]:
                        # Transition to a room if available
                        room_id = f"{self.last_world_pos[0]},{self.last_world_pos[1]}"
                        room = self.game_world.rooms.get(room_id)
                        if room and direction in room.exits:
                            self.current_room = room.exits[direction]
                            self.last_world_pos = tuple(map(int, self.current_room.split(",")))
                            self.player_pos = (2, 2)  # Reset to center
                            self.message = f"You pass through the door {direction} into a new {self.current_map} room."
                            logger.debug(f"Transitioned to room {self.current_room} via door {direction}")
                        else:
                            # Exit to world map
                            self.current_map = None
                            self.current_room = None
                            self.player_pos = self.last_world_pos
                            self.message = f"You exit the {self.current_map} through the door to the world map."
                            logger.debug(f"Exited {self.current_map} to world map via door")
                    else:
                        # For houses, exit to world map
                        self.current_map = None
                        self.current_room = None
                        self.player_pos = self.last_world_pos
                        self.message = f"You exit the {self.current_map} through the door to the world map."
                        logger.debug(f"Exited house to world map")
                else:
                    self.player_pos = new_pos
                    self.message = f"You move {direction}."
                    logger.debug(f"Moved {direction} to {new_pos}")
        else:  # Moving on the world map
            x, y = self.last_world_pos
            dx, dy = {"north": (0, 1), "south": (0, -1), "east": (1, 0), "west": (-1, 0)}[direction]
            new_x, new_y = x + dx, y + dy

            # Check map boundaries
            if not (0 <= new_x < self.world.map["width"] and 0 <= new_y < self.world.map["height"]):
                self.message = "You cannot move beyond the edge of the world!"
                logger.debug("Blocked movement: World edge")
                return

            new_pos = (new_x, new_y)

            if self.current_room:
                room = self.game_world.rooms.get(self.current_room)
                if not room:
                    self.message = f"Error: Current room {self.current_room} does not exist. Resetting room."
                    logger.error(f"Room not found: {self.current_room}")
                    self.current_room = None
                    return
                if direction in room.exits:
                    self.current_room = room.exits[direction]
                    self.last_world_pos = tuple(map(int, self.current_room.split(",")))
                    self.player_pos = (2, 2)  # Center in new room
                    self.message = f"You move {direction} to a new room."
                    logger.debug(f"Moved to room {self.current_room}")
                else:
                    self.message = "You can't go that way!"
                    logger.debug(f"Blocked movement: No exit {direction}")
            else:
                tile = self.world.get_location(*new_pos)
                if tile["type"] == "mountain":
                    self.message = "The mountains are too steep to climb!"
                    logger.debug("Blocked movement: Mountain")
                    return
                elif tile["type"] in ["river", "lake", "ocean"]:
                    self.message = f"You need a boat to cross the {tile['type']}!"
                    logger.debug(f"Blocked movement: {tile['type']}")
                    return

                # Update positions
                self.last_world_pos = new_pos
                self.player_pos = new_pos
                self.message = f"You move {direction} to {tile['name']}."
                logger.debug(f"Moved {direction} to {tile['name']} at {new_pos}")

                # Clear any temporary rooms from random encounters
                if self.current_room and "temp_" in self.current_room:
                    del self.game_world.rooms[self.current_room]
                    self.current_room = None
                    logger.debug(f"Cleared temporary room: {self.current_room}")

                # Set current_room based on the new tile type
                self.current_room = f"{self.last_world_pos[0]},{self.last_world_pos[1]}" if tile["type"] in ["dungeon", "castle"] else None

                # Enter a mini-map if available for the terrain type
                if tile["type"] in self.graphics["maps"]:
                    self.current_map = tile["type"]
                    self.player_pos = (2, 2)  # Center of the mini-map
                    self.message = self.graphics["maps"][self.current_map]["description"]
                    logger.debug(f"Entered mini-map: {self.current_map}")
                elif tile["type"] in ["plains", "forest"] and random.random() < 0.1:
                    self.message = f"A wild Goblin ambushes you!"
                    temp_room_id = f"temp_{new_pos[0]},{new_pos[1]}"
                    self.game_world.rooms[temp_room_id] = Room(
                        description="A sudden encounter in the wild!",
                        exits={},
                        monsters=[Monster("Goblin", 6, [{"attack_bonus": 3, "damage": "1d4+1"}])]
                    )
                    self.current_room = temp_room_id
                    logger.debug(f"Triggered ambush at {temp_room_id}")

    def handle_attack_command(self):
        self.message = ""  # Clear previous message
        logger.debug("Handling attack command")
        if not self.current_room:
            print("There's nothing to attack here!")
            logger.debug("No attack target: No current room")
            return
        room = self.game_world.rooms.get(self.current_room)
        if not room:
            print(f"{Fore.RED}Error: Current room {self.current_room} does not exist. Resetting room.{Style.RESET_ALL}")
            logger.error(f"Room not found: {self.current_room}")
            self.current_room = None
            return
        if not room.monsters:
            print("No monsters to attack!")
            logger.debug("No attack target: No monsters")
            return
        monster = room.monsters[0]
        bab = self.player.bab
        str_mod = self.player.get_stat_modifier(0)
        attack_roll = random.randint(1, 20) + bab + str_mod
        print(f"{self.player.name} attacks {monster.name} (Roll: {attack_roll})")
        logger.debug(f"Attack roll: {attack_roll} vs {monster.armor_class}")
        if attack_roll >= monster.armor_class:
            damage = max(1, random.randint(1, 8) + str_mod)
            monster.hp -= damage
            print(f"Hit! {monster.name} takes {damage} damage (HP: {monster.hp})")
            logger.debug(f"Hit: {monster.name} takes {damage} damage, HP now {monster.hp}")
            if monster.hp <= 0:
                print(f"{monster.name} is defeated!")
                xp_reward = self.calculate_xp_reward(monster)
                room.monsters.remove(monster)
                self.player.gain_xp(xp_reward)
                self.check_level_up()
                logger.info(f"Defeated {monster.name}, gained {xp_reward} XP")
                if "temp_" in self.current_room:
                    del self.game_world.rooms[self.current_room]
                    self.current_room = None
                    logger.debug(f"Cleared temporary room: {self.current_room}")
        else:
            print("Miss!")
            logger.debug("Attack missed")
        if room.monsters:
            self.handle_monster_attack(monster)

    def handle_monster_attack(self, monster: Monster):
        if not monster.attacks:
            print(f"{monster.name} has no attacks!")
            logger.debug(f"No attacks for {monster.name}")
            return
        attack = random.choice(monster.attacks)
        attack_roll = random.randint(1, 20) + attack["attack_bonus"]
        print(f"{monster.name} attacks {self.player.name} (Roll: {attack_roll})")
        logger.debug(f"Monster attack roll: {attack_roll} vs {self.player.armor_class}")
        if attack_roll >= self.player.armor_class:
            damage_parts = attack["damage"].split('+')
            dice_part = damage_parts[0]
            bonus = int(damage_parts[1]) if len(damage_parts) > 1 else 0
            num_dice, die_size = map(int, dice_part.split('d'))
            damage = sum(random.randint(1, die_size) for _ in range(num_dice)) + bonus
            damage = max(1, damage)
            self.player.hit_points -= damage
            print(f"Hit! {self.player.name} takes {damage} damage (HP: {self.player.hit_points})")
            logger.debug(f"Monster hit: {self.player.name} takes {damage} damage, HP now {self.player.hit_points}")
            if self.player.hit_points <= 0:
                print(f"{self.player.name} has been defeated!")
                logger.info(f"Player {self.player.name} defeated")
                self.running = False
        else:
            print("Miss!")
            logger.debug("Monster attack missed")

    def handle_cast_command(self, cmd: str):
        self.message = ""  # Clear previous message
        logger.debug(f"Handling cast command: {cmd}")
        if not self.current_room:
            print("There's nothing to cast spells on here!")
            logger.debug("No cast target: No current room")
            return
        room = self.game_world.rooms.get(self.current_room)
        if not room:
            print(f"{Fore.RED}Error: Current room {self.current_room} does not exist. Resetting room.{Style.RESET_ALL}")
            logger.error(f"Room not found: {self.current_room}")
            self.current_room = None
            return
        if not room.monsters:
            print("No monsters to cast spells on!")
            logger.debug("No cast target: No monsters")
            return
        try:
            spell_index = int(cmd.split()[-1]) - 1
            spell_list = []
            for level in sorted(self.player.known_spells.keys()):
                spell_list.extend(self.player.known_spells[level])
            if 0 <= spell_index < len(spell_list):
                spell_name = spell_list[spell_index]
                result = self.player.cast_spell(spell_name, room.monsters[0] if room.monsters else None)
                print(result)
                logger.debug(f"Cast spell: {spell_name}, Result: {result}")
                if "dealing" in result and room.monsters and room.monsters[0].hp <= 0:
                    print(f"{room.monsters[0].name} is defeated!")
                    xp_reward = self.calculate_xp_reward(room.monsters[0])
                    room.monsters.pop(0)
                    self.player.gain_xp(xp_reward)
                    self.check_level_up()
                    logger.info(f"Defeated {room.monsters[0].name} with spell, gained {xp_reward} XP")
                    if self.current_room and "temp_" in self.current_room:
                        del self.game_world.rooms[self.current_room]
                        self.current_room = None
                        logger.debug(f"Cleared temporary room: {self.current_room}")
                if room.monsters:
                    self.handle_monster_attack(room.monsters[0])
            else:
                print("Invalid spell number!")
                logger.warning("Invalid spell number")
        except (ValueError, IndexError) as e:
            print(f"{Fore.RED}Invalid cast command. Use 'cast <number>' or 'cast list'.{Style.RESET_ALL}")
            logger.error(f"Invalid cast command: {cmd}, Error: {e}")

    def print_spell_list(self):
        self.message = ""  # Clear previous message
        logger.debug("Printing spell list")
        if not self.player.known_spells or all(len(spells) == 0 for spells in self.player.known_spells.values()):
            print("You don't know any spells!")
            logger.debug("No known spells")
            return
        print("\nKnown Spells:")
        spell_index = 1
        for level in sorted(self.player.known_spells.keys()):
            for spell in self.player.known_spells[level]:
                print(f"{spell_index}. Level {level}: {spell}")
                spell_index += 1
        logger.debug(f"Displayed spell list: {self.player.known_spells}")

    def handle_rest_command(self):
        self.message = ""  # Clear previous message
        logger.debug("Handling rest command")
        self.player.hit_points = min(self.player.hit_points + 10, self.player.max_hit_points)
        self.player.mp = min(self.player.mp + 5, self.player.max_mp)
        print(f"{self.player.name} rests, recovering to {self.player.hit_points} HP and {self.player.mp} MP.")
        logger.debug(f"Player rested: HP {self.player.hit_points}, MP {self.player.mp}")

    def print_lore(self):
        self.message = ""  # Clear previous message
        logger.debug("Printing lore")
        try:
            logger.debug(f"World name: {self.world.name}, History: {self.world.history}")
            if not hasattr(self.world, 'history') or not self.world.history:
                print(f"{Fore.YELLOW}No history available for {self.world.name}.{Style.RESET_ALL}")
                logger.debug("No history available")
                return
            print(f"\n{Fore.YELLOW}History of {self.world.name}:{Style.RESET_ALL}")
            for era in self.world.history:
                print(f"\n{Fore.LIGHTYELLOW_EX}{era['name']}:{Style.RESET_ALL}")
                for event in era["events"]:
                    print(f"  {Fore.WHITE}{event['year']}: {event['desc']}{Style.RESET_ALL}")
            logger.debug("Lore displayed")
        except Exception as e:
            logger.error(f"Error printing lore: {e}")
            print(f"{Fore.RED}An error occurred while displaying the lore: {e}{Style.RESET_ALL}")

    def save_game(self):
        self.message = ""  # Clear previous message
        logger.debug("Saving game")
        try:
            save_data = self.player.to_dict()
            save_data["current_room"] = self.current_room
            save_data["player_pos"] = list(self.last_world_pos)
            save_data["world_seed"] = None  # Add if you implement seeding
            filename = f"{self.player_name.lower().replace(' ', '_')}_{int(time.time())}.save"
            self.save_manager.save_game(save_data, filename)
            print(f"{Fore.GREEN}Game saved as {filename}{Style.RESET_ALL}")
            logger.info(f"Game saved as {filename}")
        except Exception as e:
            print(f"{Fore.RED}Failed to save game: {e}{Style.RESET_ALL}")
            logger.error(f"Failed to save game: {e}")

    def display_status(self):
        """Display player stats, message, and mode-specific prompt."""
        print(f"\n{Fore.YELLOW}HP: {self.player.hit_points}/{self.player.max_hit_points} | MP: {self.player.mp}/{self.player.max_mp} | Level: {self.player.level} | XP: {self.player.xp}{Style.RESET_ALL}")
        if self.message:
            print(f"{Fore.LIGHTYELLOW_EX}{self.message}{Style.RESET_ALL}")
        if self.mode == "movement":
            print(f"\n{Fore.CYAN}Use arrow keys or WASD to move. Press Enter for commands, Esc for help.{Style.RESET_ALL}")
        else:
            print(f"\n{Fore.CYAN}Type a command ('lore', 'save', 'quit', etc.) or press Enter to return to movement.{Style.RESET_ALL}")
        logger.debug(f"Displayed status: mode={self.mode}, message={self.message}, HP={self.player.hit_points}/{self.player.max_hit_points}, MP={self.player.mp}/{self.player.max_mp}")

def main():
    global KEYBOARD_AVAILABLE  # Declare at the top to avoid SyntaxError
    logger.debug(f"Starting main loop. Terminal: {os.getenv('TERM', 'Unknown')}, stdout: {sys.stdout}")
    logger.debug(f"Keyboard library available: {KEYBOARD_AVAILABLE}")
    player_name, save_file = display_start_menu()
    if not player_name:
        print(f"{Fore.CYAN}Farewell, traveler!{Style.RESET_ALL}")
        logger.info("Game exited at start menu")
        return

    game = Game(player_name, save_file)
    game.display_current_map()  # Initial map display
    game.display_status()  # Initial status display

    # Clear input buffer
    while msvcrt.kbhit():
        msvcrt.getwch()
    time.sleep(0.3)  # Initial delay to stabilize buffer
    logger.debug("Initial input buffer cleared")

    last_refresh_time = time.time()  # Track last refresh
    last_key_time = 0  # Track last key press for debouncing

    while game.running:
        # Log loop iteration
        logger.debug(f"Main loop iteration: mode={game.mode}, pos={game.player_pos}, map={game.current_map}, kbhit={msvcrt.kbhit()}")

        # Periodic refresh (every 10 seconds)
        current_time = time.time()
        if current_time - last_refresh_time >= 10:
            game.display_current_map()
            game.display_status()
            last_refresh_time = current_time
            logger.debug("Periodic screen refresh")

        # Handle input based on mode
        if game.mode == "movement":
            # Try keyboard library first if available
            if KEYBOARD_AVAILABLE:
                try:
                    current_time = time.time()
                    if current_time - last_key_time < 0.3:  # Debounce: 300ms
                        time.sleep(0.1)
                        continue
                    # Check for keyboard events non-blocking
                    if keyboard.is_pressed("up") or keyboard.is_pressed("w"):
                        game.handle_movement("north")
                        game.display_current_map()
                        game.display_status()
                        last_refresh_time = current_time
                        last_key_time = current_time
                        logger.debug("Key pressed: up/w")
                    elif keyboard.is_pressed("down") or keyboard.is_pressed("s"):
                        game.handle_movement("south")
                        game.display_current_map()
                        game.display_status()
                        last_refresh_time = current_time
                        last_key_time = current_time
                        logger.debug("Key pressed: down/s")
                    elif keyboard.is_pressed("left") or keyboard.is_pressed("a"):
                        game.handle_movement("west")
                        game.display_current_map()
                        game.display_status()
                        last_refresh_time = current_time
                        last_key_time = current_time
                        logger.debug("Key pressed: left/a")
                    elif keyboard.is_pressed("right") or keyboard.is_pressed("d"):
                        game.handle_movement("east")
                        game.display_current_map()
                        game.display_status()
                        last_refresh_time = current_time
                        last_key_time = current_time
                        logger.debug("Key pressed: right/d")
                    elif keyboard.is_pressed("enter"):
                        if current_time - game.last_enter_time > 0.3:  # Debounce: 300ms
                            game.last_enter_time = current_time
                            game.mode = "command"
                            game.display_current_map()
                            game.display_status()
                            last_refresh_time = current_time
                            logger.debug("Switched to command mode")
                    elif keyboard.is_pressed("esc"):
                        game.display_current_map()
                        print(f"{Fore.YELLOW}Available commands: {', '.join(game.commands)}{Style.RESET_ALL}")
                        game.display_status()
                        last_refresh_time = current_time
                        last_key_time = current_time
                        logger.debug("Displayed help commands")
                    time.sleep(0.2)  # Delay for responsiveness and CPU efficiency
                except Exception as e:
                    logger.error(f"Keyboard library error: {e}")
                    print(f"{Fore.YELLOW}Warning: Keyboard library failed, falling back to msvcrt.{Style.RESET_ALL}")
                    KEYBOARD_AVAILABLE = False  # Disable keyboard library
            else:
                # Fallback to msvcrt
                try:
                    if msvcrt.kbhit():
                        current_time = time.time()
                        if current_time - last_key_time < 0.3:  # Debounce: 300ms
                            msvcrt.getwch()  # Clear key
                            time.sleep(0.1)
                            continue
                        key = msvcrt.getwch()
                        logger.debug(f"Key pressed: {repr(key.encode())}")
                        if key in ('\xe0', '\x00'):  # Arrow key prefix
                            key = msvcrt.getwch()
                            logger.debug(f"Arrow key second byte: {repr(key.encode())}")
                            if key == 'H':  # Up
                                game.handle_movement("north")
                                game.display_current_map()
                                game.display_status()
                                last_refresh_time = current_time
                                last_key_time = current_time
                            elif key == 'P':  # Down
                                game.handle_movement("south")
                                game.display_current_map()
                                game.display_status()
                                last_refresh_time = current_time
                                last_key_time = current_time
                            elif key == 'K':  # Left
                                game.handle_movement("west")
                                game.display_current_map()
                                game.display_status()
                                last_refresh_time = current_time
                                last_key_time = current_time
                            elif key == 'M':  # Right
                                game.handle_movement("east")
                                game.display_current_map()
                                game.display_status()
                                last_refresh_time = current_time
                                last_key_time = current_time
                            else:
                                logger.debug(f"Invalid arrow key second byte: {repr(key.encode())}")
                        elif key.lower() == 'w':
                            game.handle_movement("north")
                            game.display_current_map()
                            game.display_status()
                            last_refresh_time = current_time
                            last_key_time = current_time
                        elif key.lower() == 's':
                            game.handle_movement("south")
                            game.display_current_map()
                            game.display_status()
                            last_refresh_time = current_time
                            last_key_time = current_time
                        elif key.lower() == 'a':
                            game.handle_movement("west")
                            game.display_current_map()
                            game.display_status()
                            last_refresh_time = current_time
                            last_key_time = current_time
                        elif key.lower() == 'd':
                            game.handle_movement("east")
                            game.display_current_map()
                            game.display_status()
                            last_refresh_time = current_time
                            last_key_time = current_time
                        elif key == '\r':  # Enter
                            if current_time - game.last_enter_time > 0.3:  # Debounce: 300ms
                                game.last_enter_time = current_time
                                game.mode = "command"
                                game.display_current_map()
                                game.display_status()
                                last_refresh_time = current_time
                                logger.debug("Switched to command mode")
                        elif key == '\x1b':  # Esc
                            game.display_current_map()
                            print(f"{Fore.YELLOW}Available commands: {', '.join(game.commands)}{Style.RESET_ALL}")
                            game.display_status()
                            last_refresh_time = current_time
                            last_key_time = current_time
                            logger.debug("Displayed help commands")
                        else:
                            logger.debug(f"Ignored key: {repr(key.encode())}")
                        time.sleep(0.2)  # Delay for responsiveness
                    else:
                        logger.debug("No input detected, idling")
                        time.sleep(0.2)  # Idle delay
                except UnicodeDecodeError as e:
                    logger.error(f"Ignoring invalid key input: {e}")
                    time.sleep(0.2)
                except Exception as e:
                    logger.error(f"Error in movement mode: {e}")
                    print(f"{Fore.RED}Error processing input: {e}{Style.RESET_ALL}")
                    game.display_current_map()
                    game.display_status()
                    last_refresh_time = current_time
                    time.sleep(0.2)
        else:  # command mode
            print("> ", end="", flush=True)
            try:
                cmd = input().strip().lower()
            except Exception as e:
                logger.error(f"Error reading command input: {e}")
                cmd = ""
               